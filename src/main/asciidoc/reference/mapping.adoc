[[mapping.chapter]]
= Mapping

Rich object mapping support is provided by the `MappingCassandraConverter`. `MappingCassandraConverter` has a
rich metadata model that provides a complete feature set of functionality to map domain objects to CQL tables.

The mapping metadata model is populated using annotations on your domain objects. However, the infrastructure
is not limited to using annotations as the only source of metadata. The `MappingCassandraConverter` also allows you
to map domain objects to tables without providing any additional metadata, by following a set of conventions.

In this section we will describe the features of the `MappingCassandraConverter`, how to use conventions for
mapping domain objects to tables and how to override those conventions with annotation-based mapping metadata.


[[mapping-conversion]]
== Data Mapping and Type Conversion

This section explains how types are mapped to an Apache Cassandra representation and vice versa.

Spring Data for Apache Cassandra supports several types that are provided by Apache Cassandra. In addition to
these types, Spring Data for Apache Cassandra provides a set of built-in converters to map additional types.
You can provide your own custom converters to adjust type conversion, see <<cassandra.mapping.explicit-converters>>
for further details.

[cols="3,2", options="header"]
.Type
|===
| Type
| Cassandra types

| `String`
| `text` (default), `varchar`, `ascii`

| `double`, `Double`
| `double`

| `float`, `Float`
| `float`

| `long`, `Long`
| `bigint` (default), `counter`

| `int`, `Integer`
| `int`

| `short`, `Short`
| `smallint`

| `byte`, `Byte`
| `tinyint`

| `boolean`, `Boolean`
| `boolean`

| `BigInteger`
| `varint`

| `BigDecimal`
| `decimal`

| `java.util.Date`
| `timestamp`

| `com.datastax.driver.core.LocalDate`
| `date`

| `InetAddress`
| `inet`

| `ByteBuffer`
| `blob`

| `java.util.UUID`
| `timeuuid`

| `TupleValue`,  mapped Tuple Types
| `tuple<…>`

| `UDTValue`, mapped User-Defined Types
| user type

| `java.util.Map<K, V>`
| `map`

| `java.util.List<E>`
| `list`

| `java.util.Set<E>`
| `set`

| `Enum`
| `text` (default), `bigint`, `varint`, `int`, `smallint`, `tinyint`

| `LocalDate` +
(Joda, Java 8, JSR310-BackPort)
| `date`

|  `LocalTime`+
(Joda, Java 8, JSR310-BackPort)
| `time`

| `LocalDateTime`, `LocalTime`, `Instant` +
(Joda, Java 8, JSR310-BackPort)
| `timestamp`

| `ZoneId` (Java 8, JSR310-BackPort)
| `text`

|===

Each supported type maps to a default
https://docs.datastax.com/en/cql/3.3/cql/cql_reference/cql_data_types_c.html[Cassandra data type].
Java types can be mapped to other Cassandra types by using `@CassandraType`.

.Enum Mapping to Numeric Types
====
[source,java]
----
@Table
public class EnumToOrdinalMapping {

  @PrimaryKey String id;

  @CassandraType(type = Name.INT) Condition asOrdinal;
}

public enum Condition {
  NEW, USED
}
----
====

NOTE: `Enum` mapping using ordinal values requires at least Spring 4.3.0. Using earlier Spring versions requires
<<mapping-explicit-converters,custom converters>> for each `Enum` type.


[[mapping-conventions]]
== Convention-based Mapping

`MappingCassandraConverter` uses a few conventions for mapping domain objects to CQL tables when no additional
mapping metadata is provided. The conventions are:

* The simple (short) Java class name is mapped to the table name in the following manner.
The class `com.bigbank.SavingsAccount` maps to a table named, "`savingsaccount`".
* The converter will use any registered Spring `Converter`s to override the default mapping of object properties to
tables fields.
* The properties of an object are used to convert to and from properties in the table.


[[mapping-configuration]]
=== Mapping Configuration

Unless explicitly configured, an instance of `MappingCassandraConverter` is created by default when creating
a `CassandraTemplate`. You can create your own instance of the `MappingCassandraConverter` so as to tell it
where to scan the classpath at startup for your domain classes in order to extract metadata and construct indexes.

Also, by creating your own instance you can register Spring `Converter`s to use for mapping specific classes
to and from the database.

.@Configuration class to configure Cassandra mapping support
====
[source,java]
----
@Configuration
public static class Config extends AbstractCassandraConfiguration {

  @Override
  protected String getKeyspaceName() {
    return "bigbank";
  }

  // the following are optional

  @Override
  public CustomConversions customConversions() {

    List<Converter<?, ?>> converters = new ArrayList<Converter<?, ?>>();

    converters.add(new PersonReadConverter());
    converters.add(new PersonWriteConverter());

    return new CustomConversions(converters);
  }

  @Override
  public SchemaAction getSchemaAction() {
    return SchemaAction.RECREATE;
  }

  // other methods omitted...
}
----
====

`AbstractCassandraConfiguration` requires you to implement methods that define a Keyspace.
`AbstractCassandraConfiguration` also has a method you can override named  `getEntityBasePackages(…)`
which tells the converter where to scan for classes annotated with the `@Table` annotation.

You can add additional converters to the `MappingCassandraConverter` by overriding the method `customConversions`.

NOTE: `AbstractCassandraConfiguration` will create a `CassandraTemplate` instance and register it with the container
under the name `cassandraTemplate`.


[[mapping.usage]]
== Metadata-based Mapping

To take full advantage of the object mapping functionality inside the Spring Data for Apache Cassandra support,
you should annotate your mapped domain objects with the `@Table` annotation. It allows the classpath scanner to find
and pre-process your domain objects to extract the necessary metadata. Only annotated entities will be used
to perform schema actions. In the worst case, a `SchemaAction.RECREATE_DROP_UNUSED` will drop your tables
and you will lose your data.

.Example domain object
====
[source,java]
----
package com.mycompany.domain;

@Table
public class Person {

  @Id
  private String id;

  @CassandraType(type = Name.VARINT)
  private Integer ssn;

  private String firstName;

  private String lastName;
}
----
====

IMPORTANT: The `@Id` annotation tells the mapper which property you want to use for the Cassandra primary key.
Composite primary keys can require a slightly different data model.


[[cassandra-template.id-handling]]
=== Working with Primary Keys

Cassandra requires at least one partition key field for a CQL table. A table can additionally declare one or more
clustering key fields. When your CQL table has a composite primary key, you must create a `@PrimaryKeyClass` to define
the structure of the composite primary key. In this context, composite primary key means one or more partition columns
optionally combined with one or more clustering columns.

Primary keys can make use of any singular simple Cassandra type or mapped User-Defined Type.
Collection-typed primary keys are not supported.

==== Simple Primary Key

A simple primary key consists of one partition key field within an entity class. Since it's one field only,
we safely can assume it's a partition key.

.CQL Table defined in Cassandra
====
[source]
----
CREATE TABLE user (
  user_id text,
  firstname text,
  lastname text,
  PRIMARY KEY (user_id))
;
----
====

.Annotated Entity
====
[source,java]
----
@Table(value = "login_event")
public class LoginEvent {

  @PrimaryKey("user_id")
  private String userId;

  private String firstname;
  private String lastname;

  // getters and setters omitted

}
----
====

==== Composite Key

Composite primary keys (or compound keys) consist of more than one primary key field. That said, a composite primary key
can consist of multiple partition keys, a partition key and a clustering key, or a multitude of primary key fields.

Composite keys can be represented in two ways with Spring Data for Apache Cassandra:

1. Embedded in an entity.
2. By using `@PrimaryKeyClass`.

The simplest form of a composite key is a key with one partition key and one clustering key.

Here is an example of a CQL table and the corresponding POJOs that represent the table and it's composite key.

.CQL Table with a Composite Primary Key
====
[source]
----
CREATE TABLE login_event(
  person_id text,
  event_code int,
  event_time timestamp,
  ip_address text,
  PRIMARY KEY (person_id, event_code, event_time))
  WITH CLUSTERING ORDER BY (event_time DESC)
;
----
====

==== Flat Composite Primary Key

Flat composite primary keys are embedded inside the entity as flat fields. Primary key fields are annotated with
`@PrimaryKeyColumn` along with other fields in the entity. Selection requires either a query to contain predicates
for the individual fields or the use of `MapId`.

.Using a flat Composite Primary Key
====
[source,java]
----
@Table(value = "login_event")
public class LoginEvent {

  @PrimaryKeyColumn(name = "person_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
  private String personId;

  @PrimaryKeyColumn(name = "event_code", ordinal = 1, type = PrimaryKeyType.PARTITIONED)
  private int eventCode;

  @PrimaryKeyColumn(name = "event_time", ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
  private Date eventTime;

  @Column("ip_address)
  private String ipAddress;

  // getters and setters omitted
}
----
====

==== Primary Key Class

A primary key class is a composite primary key class that is mapped to multiple fields or properties of the entity.
It's annotated with `@PrimaryKeyClass` and defines `equals` and `hashCode` methods. The semantics of value equality
for these methods should be consistent with the database equality for the database types to which the key is mapped.
Primary key classes can be used with _Repositories_ (as the Id type) and to represent an entities' identity
in a single complex object.

.Composite Primary Key Class
====
[source,java]
----
@PrimaryKeyClass
public class LoginEventKey implements Serializable {

  @PrimaryKeyColumn(name = "person_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
  private String personId;

  @PrimaryKeyColumn(name = "event_code", ordinal = 1, type = PrimaryKeyType.PARTITIONED)
  private int eventCode;

  @PrimaryKeyColumn(name = "event_time", ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
  private Date eventTime;

  // other methods omitted
}
----
====

.Using a Composite Primary Key
====
[source,java]
----
@Table(value = "login_event")
public class LoginEvent {

  @PrimaryKey
  private LoginEventKey key;

  @Column("ip_address)
  private String ipAddress;

  // getters and setters omitted
}
----
====

NOTE: `PrimaryKeyClass` must implement `Serializable` and should provide implementations of `equals()` and `hashCode()`.


[[mapping.usage-annotations]]
=== Mapping annotation overview

The `MappingCassandraConverter` can use metadata to drive the mapping of objects to rows in a Cassandra table.
An overview of the annotations is provided below:

* `@Id` - applied at the field or property level to mark the property used for identity purpose.
* `@Table` - applied at the class level to indicate this class is a candidate for mapping to the database.
You can specify the name of the table where the object will be stored.
* `@PrimaryKey` - Similar to `@Id` but allows you to specify the column name.
* `@PrimaryKeyColumn` - Cassandra-specific annotation for primary key columns that allows you to specify
primary key column attributes such as for clustered/partitioned. Can be used on single and multiple attributes
to indicate either a single or a composite (compound) primary key.
* `@PrimaryKeyClass` - applied at the class level to indicate this class is a compound primary key class.
Requires to be referenced with `@PrimaryKey` in the entity class.
* `@Transient` - by default all private fields are mapped to the row, this annotation excludes the field
where it is applied from being stored in the database.
* `@Column` - applied at the field level. Describes the column name as it will be represented in the Cassandra table
thus allowing the name to be different than the field name of the class.
* `@Indexed` - applied at the field level. Describes the index to be created at session initialization.
* `@SASI` - applied at the field level. Allows SASI index creation during session initialization.
* `@CassandraType` - applied at the field level to specify a Cassandra data type.
Types are derived from the property declaration by default.
* `@UserDefinedType` - applied at the type level to specify a Cassandra User-defined Data Type (UDT).
Types are derived from the declaration by default.
* `@Tuple` - applied at the type level to use a type as a mapped tuple.
* `@Element` - applied at the field level to specify element/field ordinals within a mapped tuple.
Types are derived from the property declaration by default.

The mapping metadata infrastructure is defined in the separate, spring-data-commons project that is both
technology and data store agnostic.

Here is an example of a more complex mapping.

.Mapped `Person` class
====
[source,java]
----
@Table("my_person")
public class Person {

  @PrimaryKeyClass
  public static class Key implements Serializable {

    @PrimaryKeyColumn(ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    private String type;

    @PrimaryKeyColumn(ordinal = 1, type = PrimaryKeyType.PARTITIONED)
    private String value;

    @PrimaryKeyColumn(name = "correlated_type", ordinal = 2, type = PrimaryKeyType.CLUSTERED)
    private String correlatedType;

    // other getters/setters ommitted
  }

  @PrimaryKey
  private Person.Key key;

  @CassandraType(type = Name.VARINT)
  private Integer ssn;

  @Column("f_name")
  private String firstName;

  @Column(forceQuote = true)
  @Indexed
  private String lastName;

  private Address address;

  @CassandraType(type = Name.UDT, userTypeName = "myusertype")
  private UDTValue usertype;

  private Coordinates coordinates;

  @Transient
  private Integer accountTotal;

  @CassandraType(type = Name.SET, typeArguments = Name.BIGINT)
  private Set<Long> timestamps;

  private Map<@Indexed String, InetAddress> sessions;

  public Person(Integer ssn) {
    this.ssn = ssn;
  }

  public String getId() {
    return id;
  }

  // no setter for Id.  (getter is only exposed for some unit testing)

  public Integer getSsn() {
    return ssn;
  }

  // other getters/setters ommitted
}
----
====

.Mapped User-Defined type `Address`
====
[source,java]
----
@UserDefinedType("address")
public class Address {

  @CassandraType(type = Name.VARCHAR)
  private String street;

  private String city;

  private Set<String> zipcodes;

  @CassandraType(type = Name.SET, typeArguments = Name.BIGINT)
  private List<Long> timestamps;

  // other getters/setters ommitted
}
----
====

NOTE: Working with User-Defined Types requires a `UserTypeResolver` configured with the mapping context.
See the <<cassandra.connectors,configuration chapter>> for how to configure a `UserTypeResolver`.

.Mapped Tuple
====
[source,java]
----
@Tuple
public class Coordinates {

  @Element(0)
  @CassandraType(type = Name.VARCHAR)
  private String description;

  @Element(1)
  private long longitude;

  @Element(2)
  private long latitude;

  // other getters/setters ommitted
}
----
====

==== Index creation

You can annotate particular entity properties with `@Indexed` or `@SASI` if you wish to create Secondary Indexes
on application startup. Index creation will create simple Secondary Indexes for scalar types, user-defined,
and collection types.

You can configure a SASI Index to apply an analyzer such as `StandardAnalyzer` or `NonTokenizingAnalyzer` via
`@StandardAnalyzed` respective `@NonTokenizingAnalyzed`.

Map types distinguish between `ENTRY`, `KEYS` and `VALUES` Indexes. Index creation derives the Index type
from the annotated element:

.Variants of map indexing
====
[source,java]
----
@Table
public class Person {

  @Id
  private String key;

  @SASI @StandardAnalyzed
  private String names;

  @Indexed("indexed_map")
  private Map<String, String> entries;

  private Map<@Indexed String, String> keys;

  private Map<String, @Indexed String> values;

  // …
}
----
====

WARNING: Index creation on session initialization may have a severe performance impact on application startup.


[[cassandra.mapping.explicit-converters]]
=== Overriding Mapping with explicit Converters

When storing and querying your objects it is convenient to have a `CassandraConverter` instance handle the mapping
of all Java types to Rows. However, sometimes you may want the `CassandraConverter` to do most of the work
but still allow you to selectively handle the conversion for a particular type, or to optimize performance.

To selectively handle the conversion yourself, register one or more `org.springframework.core.convert.converter.Converter`
instances with the `CassandraConverter`.

NOTE: Spring 3.0 introduced a `o.s.core.convert` package that provides a general type conversion system.
This is described in detail in the Spring reference documentation section entitled
{spring-framework-docs}core.html#core-convert[Spring Type Conversion].

Below is an example of a Spring `Converter` implementation that converts from a Row to a Person POJO.

[source,java]
----
@ReadingConverter
 public class PersonReadConverter implements Converter<Row, Person> {

  public Person convert(Row source) {
    Person person = new Person(row.getString("id"));
    person.setAge(source.getInt("age");
    return person;
  }
}
----


[[cassandra.mapping-usage.events]]
== Lifecycle Events

Built into the Cassandra mapping framework are several `org.springframework.context.ApplicationEvent` events that your application can respond to by registering special beans in the `ApplicationContext`. By being based on Spring's application context event infrastructure this enables other products, such as Spring Integration, to easily receive these events as they are a well known eventing mechanism in Spring based applications.

To intercept an object before it goes into the database, you'd register a subclass of `org.springframework.data.cassandra.core.mapping.event.AbstractCassandraEventListener` that overrides the `onBeforeSave(…)` method. When the event is dispatched, your listener will be called and passed the domain object (Java entity).

====
[source,java]
----
public class BeforeSaveListener extends AbstractCassandraEventListener<Person> {
  @Override
  public void onBeforeSave(BeforeSaveEvent<Person> event) {
    … change values, delete them, whatever …
  }
}
----
====

Simply declaring these beans in your Spring `ApplicationContext` will cause them to be invoked whenever the event is dispatched.

The list of callback methods that are present in `AbstractCassandraEventListener` are:

* `onBeforeSave` - called in `CassandraTemplate.insert(…)` and `.update(…)` operations *before* inserting/updating a row in the database.
* `onAfterSave` - called in `CassandraTemplate…insert(…)` and `.update(…)` operations *after* inserting/updating a row in the database.
* `onBeforeDelete` - called in `CassandraTemplate.delete(…)` operations *before* deleting row from the database.
* `onAfterDelete` - called in `CassandraTemplate.delete(…)` operations *after* deleting row from the database.
* `onAfterLoad` - called in `CassandraTemplate.#select(…)`, `.slice(…)`, and `.stream(…)` methods after each row retrieved from the database.
* `onAfterConvert` - called in `CassandraTemplate.#select(…)`, `.slice(…)`, and `.stream(…)` methods after converting a row retrieved from the database to a POJO.

NOTE: Lifecycle events are only emitted for root level types. Complex types used as properties within an aggregate root are not subject of event publication.

