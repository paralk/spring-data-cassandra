[[cassandra.core]]
= Cassandra support

Spring Data support for Apache Cassandra contains a wide range of features which are summarized below.

* _Spring_ configuration support using Java-based `@Configuration` classes or the XML namespace.
* `CqlTemplate` helper class that increases productivity by handling common Cassandra data access operations properly.
* `CassandraTemplate` helper class providing object mapping between CQL Tables and POJOs.
* Exception translation into _Spring's_ portable {spring-framework-docs}data-access.html#dao-exceptions[Data Access Exception Hierarchy].
* Feature rich object mapping integrated with _Spring's_ {spring-framework-docs}core.html#core-convert[Conversion Service].
* Annotation-based mapping metadata that is extensible to support other metadata formats.
* Java-based Query, Criteria, and Update DSLs.
* Automatic implementation of `Repository` interfaces including support for custom finder methods.

For most data-oriented tasks you will use the `CassandraTemplate` or the `Repository` support, which leverage the
rich object mapping functionality. `CqlTemplate` is commonly used to increment counters or perform ad-hoc CRUD
operations. `CqlTemplate` also provides callback methods making it easy to get a hold of low-level API objects
such as `com.datastax.driver.core.Session` allowing you to communicate directly with Cassandra.
Spring Data for Apache Cassandra uses consistent naming conventions on objects in various APIs to those found in
the DataStax Java Driver so that they are familiar and so you can map your existing knowledge onto the _Spring_ APIs.

[[cassandra.getting-started]]
== Getting Started

Spring Data for Apache Cassandra requires Apache Cassandra 2.1 or higher, Datastax Java Driver 3.0 or higher
and Java SE 8 or higher. An easy way to quickly setup and bootstrap a working environment is to create
a Spring-based project in http://spring.io/tools/sts[STS] or use http://start.spring.io/[Spring Initializer].

First, you need to setup a running Apache Cassandra server. Refer to the
http://cassandra.apache.org/doc/latest/getting_started/index.html[Apache Cassandra Quick Start Guide]
for an explanation on how to startup Apache Cassandra. Once installed, starting Cassandra is typically a matter of
executing the following command: `CASSANDRA_HOME/bin/cassandra -f`

To create a Spring project in STS go to File -> New -> Spring Template Project -> Simple Spring Utility Project
and press Yes when prompted. Then enter a project and a package name such as `org.spring.data.cassandra.example`.

Then, add the following dependency declaration to your _pom.xml_ `dependencies` section.

[source,xml,subs="verbatim,attributes"]
----
<dependencies>

  <dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-cassandra</artifactId>
    <version>{version}</version>
  </dependency>

</dependencies>
----

Also, change the version of Spring in the _pom.xml_ to be

[source,xml,subs="verbatim,attributes"]
----
<spring.framework.version>{springVersion}</spring.framework.version>
----

If using a milestone release instead of a GA release, you will also need to add the location of the Spring Milestone
repository for Maven to your _pom.xml_, which is at the same level of your `<dependencies/>` element.

[source,xml]
----
<repositories>
  <repository>
    <id>spring-milestone</id>
    <name>Spring Maven MILESTONE Repository</name>
    <url>http://repo.spring.io/libs-milestone</url>
  </repository>
</repositories>
----

The repository is also http://repo.spring.io/milestone/org/springframework/data/[browseable here].

You can also browse all Spring repositories https://repo.spring.io/webapp/#/home[here].

Now, we will create a simple Java application that stores and reads a domain object to/from Cassandra.

First, create a simple domain object class to persist.

[source,java]
----
package org.spring.data.cassandra.example;

import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

@Table
public class Person {

  @PrimaryKey
  private final String id;

  private final String name;
  private final int age;

  public Person(String id, String name, int age) {
    this.id = id;
    this.name = name;
    this.age = age;
  }

  public String getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return String.format("{ @type = %1$s, id = %2$s, name = %3$s, age = %4$d }",
      getClass().getName(), getId(), getName(), getAge());
  }
}
----

Next, create the main application to run.

[source,java]
----
package org.spring.data.cassandra.example;

import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.cassandra.core.CassandraOperations;
import org.springframework.data.cassandra.core.CassandraTemplate;
import org.springframework.data.cassandra.core.query.Criteria;
import org.springframework.data.cassandra.core.query.Query;

import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.Session;

public class CassandraApplication {

  private static final Logger LOGGER = LoggerFactory.getLogger(CassandraApplication.class);

  protected static Person newPerson(String name, int age) {
    return newPerson(UUID.randomUUID().toString(), name, age);
  }

  protected static Person newPerson(String id, String name, int age) {
    return new Person(id, name, age);
  }

  public static void main(String[] args) {

    Cluster cluster = Cluster.builder().addContactPoints("localhost").build();
    Session session = cluster.connect("mykeyspace");

    CassandraOperations template = new CassandraTemplate(session);

    Person jonDoe = template.insert(newPerson("Jon Doe", 40));

    LOGGER.info(template.selectOne(Query.query(Criteria.where("id").is(jonDoe.getId())), Person.class).getId());

    template.truncate(Person.class);
    session.close();
    cluster.close();
  }
}
----

Even in this simple example, there are a few things to observe.

* You can create an instance of `CassandraTemplate` with a Cassandra `Session`, obtained from `Cluster`.
* You must annotate your POJO as a Cassandra `@Table` entity and also annotate the `@PrimaryKey`.
Optionally, you can override these mapping names to match your Cassandra database table and column names.
* You can either use raw CQL or the DataStax `QueryBuilder` API to construct your queries.

[[cassandra.examples-repo]]
== Examples Repository

There is a https://github.com/spring-projects/spring-data-examples[Github repository with several examples] that you
can download and play around with to get a feel for how the library works.

[[cassandra.connectors]]
== Connecting to Cassandra with Spring

One of the first tasks when using Apache Cassandra with Spring is to create a `com.datastax.driver.core.Session` object
using the Spring IoC container. There are two main ways to do this, either using Java-based bean metadata or XML-based
bean metadata. These are discussed in the following sections.

NOTE: For those not familiar with how to configure the Spring container using Java-based bean metadata instead of
XML-based metadata, see the high-level introduction in the reference docs
http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html#new-java-configuration[here]
as well as the detailed documentation {spring-framework-docs}core.html#beans-java-instantiating-container[here].

[[cassandra.cassandra-java-config]]
=== Registering a Session instance using Java-based metadata

An example of using Java-based bean metadata to register an instance of a `com.datastax.driver.core.Session`
is shown below.

.Registering a com.datastax.driver.core.Session object using Java based bean metadata
====
[source,java]
----
@Configuration
public class AppConfig {

  /*
   * Use the standard Cassandra driver API to create a com.datastax.driver.core.Session instance.
   */
  public @Bean Session session() {
    Cluster cluster = Cluster.builder().addContactPoints("localhost").build();
    return cluster.connect("mykeyspace");
  }
}
----
====

This approach allows you to use the standard `com.datastax.driver.core.Session` API that you may already be used
to using.

An alternative is to register an instance of `com.datastax.driver.core.Session` instance with the container
using Spring's `CassandraCqlSessionFactoryBean` and `CassandraCqlClusterFactoryBean`. As compared to instantiating
a `com.datastax.driver.core.Session` instance directly, the `FactoryBean` approach has the added advantage of also
providing the container with an `ExceptionTranslator` implementation that translates Cassandra exceptions to exceptions
in Spring's portable `DataAccessException` hierarchy for data access classes annotated. This hierarchy and use of
`@Repository` is described in {spring-framework-docs}data-access.html[Spring's DAO support features].

An example of a Java-based bean metadata that supports exception translation on `@Repository` annotated classes
is shown below:

.Registering a com.datastax.driver.core.Session object using Spring's CassandraCqlSessionFactoryBean and enabling Spring's exception translation support
====
[source,java]
----
@Configuration
public class AppConfig {

  /*
   * Factory bean that creates the com.datastax.driver.core.Session instance
   */
  @Bean
  public CassandraCqlClusterFactoryBean cluster() {

    CassandraCqlClusterFactoryBean cluster = new CassandraCqlClusterFactoryBean();
    cluster.setContactPoints("localhost");

    return cluster;
  }

   /*
    * Factory bean that creates the com.datastax.driver.core.Session instance
    */
   @Bean
   public CassandraCqlSessionFactoryBean session() {

    CassandraCqlSessionFactoryBean session = new CassandraCqlSessionFactoryBean();
    session.setCluster(cluster().getObject());
    session.setKeyspaceName("mykeyspace");

    return session;
  }
}
----
====

Using `CassandraTemplate` with object mapping and _Repository_ support requires a `CassandraTemplate`,
`CassandraMappingContext`, `CassandraConverter` and enabling _Repository_ support.

.Registering components to configure object mapping and repository support
====
[source,java]
----
@Configuration
@EnableCassandraRepositories(basePackages = { "org.spring.cassandra.example.repo" })
public class CassandraConfig {

  @Bean
  public CassandraClusterFactoryBean cluster() {

    CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean();
    cluster.setContactPoints("localhost");

    return cluster;
  }

  @Bean
  public CassandraMappingContext mappingContext() {

    BasicCassandraMappingContext mappingContext =  new BasicCassandraMappingContext();
    mappingContext.setUserTypeResolver(new SimpleUserTypeResolver(cluster().getObject(), "mykeyspace"));

    return mappingContext;
  }

  @Bean
  public CassandraConverter converter() {
    return new MappingCassandraConverter(mappingContext());
  }

  @Bean
  public CassandraSessionFactoryBean session() throws Exception {

    CassandraSessionFactoryBean session = new CassandraSessionFactoryBean();
    session.setCluster(cluster().getObject());
    session.setKeyspaceName("mykeyspace");
    session.setConverter(converter());
    session.setSchemaAction(SchemaAction.NONE);

    return session;
  }

  @Bean
  public CassandraOperations cassandraTemplate() throws Exception {
    return new CassandraTemplate(session().getObject());
  }
}
----
====

Creating configuration classes registering Spring Data for Apache Cassandra components can be an exhausting challenge
so Spring Data for Apache Cassandra comes with a prebuilt configuration support class. Classes extending from
`AbstractCassandraConfiguration` will register beans for Spring Data for Apache Cassandra use.
`AbstractCassandraConfiguration` lets you provide various configuration options such as initial entities,
default query options, pooling options, socket options and much more. `AbstractCassandraConfiguration` will support
you also with schema generation based on initial entities, if any are provided. Extending from
`AbstractCassandraConfiguration` requires you to at least provide the Keyspace name by implementing
the `getKeyspaceName` method.

.Registering Spring Data for Apache Cassandra beans using `AbstractCassandraConfiguration`
====
[source,java]
----
@Configuration
public class AppConfig extends AbstractCassandraConfiguration {

  /*
   * Provide a contact point to the configuration.
   */
  public String getContactPoints() {
    return "localhost";
  }

  /*
   * Provide a keyspace name to the configuration.
   */
  public String getKeyspaceName() {
    return "mykeyspace";
  }
}
----
====

[[cassandra-connectors.xmlconfig]]
=== XML Configuration

[[cassandra-connectors.xmlconfig.ext_properties]]
==== Externalize Connection Properties

Create a properties file containing the information needed to connect to Cassandra. `contactpoints` and `keyspace`
are required fields; `port` has been added for clarity.

We will call this properties file, `cassandra.properties`.

[source]
----
cassandra.contactpoints=10.1.55.80,10.1.55.81
cassandra.port=9042
cassandra.keyspace=showcase
----

We will use Spring to load these properties into the Spring context in the next two examples.

==== Registering a Session instance using XML-based metadata

While you can use Spring's traditional `<beans/>` XML namespace to register an instance of
`com.datastax.driver.core.Session` with the container, the XML can be quite verbose as it is general purpose.
XML namespaces are a better alternative to configuring commonly used objects such as the `Session` instance.
The `cql` and `cassandra` namespaces allow you to create a `Session` instance.

To use the Cassandra namespace elements you will need to reference the Cassandra schema:

.XML schema to configure Cassandra using the `cql` namespace
====
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:cql="http://www.springframework.org/schema/data/cql"
  xsi:schemaLocation="
    http://www.springframework.org/schema/cql
    http://www.springframework.org/schema/cql/spring-cql.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

  <!-- Default bean name is 'cassandraCluster' -->
  <cql:cluster contact-points="localhost" port="9042">
    <cql:keyspace action="CREATE_DROP" name="mykeyspace" />
  </cql:cluster>

  <!-- Default bean name is 'cassandraSession' -->
  <cql:session keyspace-name="mykeyspace" />

</beans>
----
====

.XML schema to configure Cassandra using the `cassandra` namespace
====
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:cassandra="http://www.springframework.org/schema/data/cassandra"
  xsi:schemaLocation="
    http://www.springframework.org/schema/data/cassandra
    http://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

  <!-- Default bean name is 'cassandraCluster' -->
  <cassandra:cluster contact-points="localhost" port="9042">
    <cassandra:keyspace action="CREATE_DROP" name="mykeyspace" />
  </cassandra:cluster>

  <!-- Default bean name is 'cassandraSession' -->
  <cassandra:session keyspace-name="${cassandra.keyspace}" schema-action="NONE" />

</beans>
----
====

NOTE: You may have noticed the slight difference between namespaces: `cql` and `cassandra`. Using the `cql` namespace
is limited to low-level CQL support while `cassandra` extends the `cql` namespace with object mapping
and schema generation support.

The XML configuration elements for more advanced Cassandra configuration are shown below. These elements all use
default bean names to keep the configuration code clean and readable.

While this example shows how easy it is to configure Spring to connect to Cassandra, there are many other options.
Basically, any option available with the DataStax Java Driver is also available in the Spring Data for Apache Cassandra
configuration. This is including, but not limited to Authentication, Load Balancing Policies, Retry Policies
and Pooling Options. All of the Spring Data for Apache Cassandra method names and XML elements are named exactly
(or as close as possible) like the configuration options on the driver so mapping any existing driver configuration
should be straight forward.

.Configuring Spring Data Components via XML
====
[source,xml]
----

<!-- Loads the properties into the Spring Context and uses them to fill
in placeholders in the bean definitions -->
<context:property-placeholder location="classpath:cassandra.properties" />

<!-- REQUIRED: The Cassandra Cluster -->
<cassandra:cluster contact-points="${cassandra.contactpoints}"
port="${cassandra.port}" />

<!-- REQUIRED: The Cassandra Session, built from the Cluster, and attaching
to a keyspace -->
<cassandra:session keyspace-name="${cassandra.keyspace}" />

<!-- REQUIRED: The Default Cassandra Mapping Context used by CassandraConverter -->
<cassandra:mapping>
  <cassandra:user-type-resolver keyspace-name="${cassandra.keyspace}" />
</cassandra:mapping>

<!-- REQUIRED: The Default Cassandra Converter used by CassandraTemplate -->
<cassandra:converter />

<!-- REQUIRED: The Cassandra Template is the building block of all Spring
Data Cassandra -->
<cassandra:template id="cassandraTemplate" />

<!-- OPTIONAL: If you are using Spring Data for Apache Cassandra Repositories, add
your base packages to scan here -->
<cassandra:repositories base-package="org.spring.cassandra.example.repo" />

----
====

[[cassandra.schema-management]]
== Schema Management

Apache Cassandra is a data store that requires a schema definition prior to any data interaction.
Spring Data for Apache Cassandra can support you with schema creation.

=== Keyspaces and Lifecycle scripts

The very first thing to start with is a Cassandra Keyspace. A Keyspace is a logical grouping of tables that share
the same replication factor and replication strategy. Keyspace management is located in the `Cluster` configuration,
which has the notion of `KeyspaceSpecification` and startup/shutdown CQL script execution.

Declaring a Keyspace with a specification allows creating/dropping of the Keyspace. It will derive CQL from
the specification so you're not required to write CQL yourself.

.Specifying a Cassandra Keyspace via XML
====
[source,xml]
----
<cql:cluster>

    <cql:keyspace action="CREATE_DROP" durable-writes="true" name="my_keyspace">

    <cql:replication class="NETWORK_TOPOLOGY_STRATEGY">
      <cql:data-center name="foo" replication-factor="1" />
      <cql:data-center name="bar" replication-factor="2" />
    </cql:replication>
  </cql:keyspace>

</cql:cluster>
----
====

.Specifying a Cassandra Keyspace via JavaConfig
====
[source,java]
----
@Configuration
public abstract class AbstractCassandraConfiguration extends AbstractClusterConfiguration
		implements BeanClassLoaderAware {

  @Override
  protected List<CreateKeyspaceSpecification> getKeyspaceCreations() {

    CreateKeyspaceSpecification specification = CreateKeyspaceSpecification.createKeyspace("my_keyspace")
      .with(KeyspaceOption.DURABLE_WRITES, true)
      .withNetworkReplication(DataCenterReplication.dcr("foo", 1), DataCenterReplication.dcr("bar", 2));

    return Arrays.asList(specification);
  }

  @Override
  protected List<DropKeyspaceSpecification> getKeyspaceDrops() {
    return Arrays.asList(DropKeyspaceSpecification.dropKeyspace("my_keyspace"));
  }

  // ...
}
----
====

Startup/shutdown CQL execution follows a slightly different approach that is bound to the `Cluster` lifecycle.
You can provide arbitrary CQL that is executed on `Cluster` initialization and shutdown in the `SYSTEM` keyspace.

.Specifying Startup/Shutdown scripts via XML
====
[source,xml]
----
<cql:cluster>
  <cql:startup-cql><![CDATA[
CREATE KEYSPACE IF NOT EXISTS my_other_keyspace WITH durable_writes = true AND replication = { 'replication_factor' : 1, 'class' : 'SimpleStrategy' };
    ]]></cql:startup-cql>
  <cql:shutdown-cql><![CDATA[
DROP KEYSPACE my_other_keyspace;
    ]]></cql:shutdown-cql>
</cql:cluster>
----
====

.Specifying a Startup/Shutdown scripts via JavaConfig
====
[source,java]
----
@Configuration
public class CassandraConfiguration extends AbstractCassandraConfiguration {

  @Override
  protected List<String> getStartupScripts() {

    String script = "CREATE KEYSPACE IF NOT EXISTS my_other_keyspace "
      + "WITH durable_writes = true "
      + "AND replication = { 'replication_factor' : 1, 'class' : 'SimpleStrategy' };";

    return Arrays.asList(script);
  }

  @Override
  protected List<String> getShutdownScripts() {
    return Arrays.asList("DROP KEYSPACE my_other_keyspace;");
  }

  // ...
}
----
====

NOTE: `KeyspaceSpecifications` and lifecycle CQL scripts are available with the `cql` and `cassandra` namespaces.

NOTE: Keyspace creation allows rapid bootstrapping without the need of external Keyspace management. This can be useful
for certain scenarios but should be used with care. Dropping a Keyspace on application shutdown will remove the Keyspace
and all data from the tables in the Keyspace.

=== Tables and User-defined types

Spring Data for Apache Cassandra's approaches data access with mapped entity classes that fit your data model.
These entity classes can be used to create Cassandra table specifications and user type definitions.

Schema creation is tied to `Session` initialization with `SchemaAction`. The following actions are supported:

* `SchemaAction.NONE`: No tables/types will be created or dropped. This is the default setting.
* `SchemaAction.CREATE`: Create tables, indexes and user-defined types from entities annotated with `@Table` and types annotated with `@UserDefinedType`. Existing tables/types will cause an error if the type is attempted to be created.
* `SchemaAction.CREATE_IF_NOT_EXISTS`: Like `SchemaAction.CREATE` but with `IF NOT EXISTS` applied. Existing tables/types won't cause any errors but may remain stale.
* `SchemaAction.RECREATE`: Drops and recreate existing tables and types that are known to be used. Tables and types that are not configured in the application are not dropped.
* `SchemaAction.RECREATE_DROP_UNUSED`: Drop all tables and types and recreate only known tables and types.

NOTE: `SchemaAction.RECREATE`/`SchemaAction.RECREATE_DROP_UNUSED` will drop your tables and you will lose all data.
`RECREATE_DROP_UNUSED` also drops tables and types that are not known to the application.

==== Enabling Tables and User-Defined Types for Schema Management

<<mapping.usage>> explains object mapping using conventions and annotations. Schema management is only active
for entities annotated with `@Table` and user-defined types annotated with `@UserDefinedType` to prevent
unwanted classes from being created as table/type. Entities are discovered by scanning the classpath.
Entity scanning requires one or more base packages. Tuple typed columns using `TupleValue` do not provide
any typing details hences you must annotate such column properties with `@CassandraType(type = TUPLE, typeArguments = …)`
to specify the desired column type.

.Specifying Entity Base Packages via XML
====
[source,xml]
----

<cassandra:mapping entity-base-packages="com.foo,com.bar"/>

----
====

.Specifying Entity Base Packages via JavaConfig
====
[source,java]
----
@Configuration
public class CassandraConfiguration extends AbstractCassandraConfiguration {

	@Override
	public String[] getEntityBasePackages() {
		return new String[] { "com.foo", "com.bar" };
	}

	// ...
}
----
====

[[cassandra.cql-template]]
== CqlTemplate

The `CqlTemplate` class is the central class in the core CQL package. It handles the creation and release of resources.
It performs the basic tasks of the core CQL workflow such as statement creation and execution, leaving application code
to provide CQL and extract results. The `CqlTemplate` class executes CQL queries and update statements, performs
iteration over ``ResultSet``s and extraction of returned parameter values. It also catches CQL exceptions and translates
them to the generic, more informative, exception hierarchy defined in the `org.springframework.dao` package.

When you use the `CqlTemplate` for your code, you only need to implement callback interfaces, which have a very clearly
defined contract. Given a `Connection` the `PreparedStatementCreator` callback interface creates a prepared statement
with the provided CQL and any necessary parameter arguments. The `RowCallbackHandler` interface extracts values
from each row of a `ResultSet`.

The `CqlTemplate` can be used within a DAO implementation through direct instantiation with a `SessionFactory` reference,
or be configured in the Spring container and given to DAOs as a bean reference. `CqlTemplate` is a foundational building
block for <<cassandra-template,`CassandraTemplate`>>.

All CQL issued by this class is logged at the `DEBUG` level under the category corresponding to the fully-qualified class
name of the template instance (typically `CqlTemplate`, but it may be different if you are using a custom subclass
of the `CqlTemplate` class).

You can control fetch size, consistency level and retry policy defaults by configuring these parameters
on the CQL API instances `CqlTemplate`, `AsyncCqlTemplate`, and `ReactiveCqlTemplate`. Defaults apply if the particular
query option is not set.

NOTE: `CqlTemplate` comes in different execution model flavors. The basic `CqlTemplate` uses a blocking execution model.
You can use `AsyncCqlTemplate` for asynchronous execution and synchronization with ``ListenableFuture``s or
<<cassandra.reactive.cql-template,`ReactiveCqlTemplate`>> for reactive execution.

[[cassandracql-template.examples]]
=== Examples of `CqlTemplate` class usage

This section provides some examples of the `CqlTemplate` class in action. These examples are not an exhaustive list
of all of the functionality exposed by the `CqlTemplate`; see the attendant Javadocs for that.

[[cassandra.cql-template.examples.query]]
==== Querying (SELECT) with `CqlTemplate`
Here is a simple query for getting the number of rows in a relation:

[source,java]
----
int rowCount = cqlTemplate.queryForObject("select count(*) from t_actor", Integer.class);
----

A simple query using a bind variable:

[source,java]
----
int countOfActorsNamedJoe = cqlTemplate.queryForObject(
		"select count(*) from t_actor where first_name = ?", Integer.class, "Joe");
----

Querying for a `String`:

[source,java]
----
String lastName = cqlTemplate.queryForObject(
		"select last_name from t_actor where id = ?",
		String.class, 1212L);
----

Querying and populating a __single__ domain object:

[source,java]
----
Actor actor = cqlTemplate.queryForObject(
		"select first_name, last_name from t_actor where id = ?",
		new RowMapper<Actor>() {
			public Actor mapRow(Row row, int rowNum) {
				Actor actor = new Actor();
				actor.setFirstName(row.getString("first_name"));
				actor.setLastName(row.getString("last_name"));
				return actor;
			},
      new Object[]{1212L},
		});
----

Querying and populating a number of domain objects:

[source,java]
----
List<Actor> actors = cqlTemplate.query(
		"select first_name, last_name from t_actor",
		new RowMapper<Actor>() {
			public Actor mapRow(Row row int rowNum) {
				Actor actor = new Actor();
				actor.setFirstName(row.getString("first_name"));
				actor.setLastName(row.getString("last_name"));
				return actor;
			}
		});
----

If the last two snippets of code actually existed in the same application, it would make sense to remove the
duplication present in the two `RowMapper` anonymous inner classes, and extract them out into a single class
(typically a `static` nested class) that can then be referenced by DAO methods as needed.

For example, it may be better to write the last code snippet as follows:

[source,java]
----
public List<Actor> findAllActors() {
	return cqlTemplate.query("select first_name, last_name from t_actor", ActorMapper.INSTANCE);
}

enum ActorMapper implements RowMapper<Actor> {

    INSTANCE;

	public Actor mapRow(Row row, int rowNum) {
		Actor actor = new Actor();
		actor.setFirstName(row.getString("first_name"));
		actor.setLastName(row.getString("last_name"));
		return actor;
	}
}
----

[[cassandra.cql-template.examples.update]]
==== Updating (INSERT/UPDATE/DELETE) with `CqlTemplate`

You use the `execute(…)` method to perform INSERT, UPDATE and DELETE operations. Parameter values are usually provided
as var args or alternatively as an object array.

[source,java]
----
cqlTemplate.execute(
		"INSERT INTO t_actor (first_name, last_name) VALUES (?, ?)",
		"Leonor", "Watling");
----

[source,java]
----
cqlTemplate.execute(
		"UPDATE t_actor SET last_name = ? WHERE id = ?",
		"Banjo", 5276L);
----

[source,java]
----
cqlTemplate.execute(
		"DELETE FROM actor WHERE id = ?",
		Long.valueOf(actorId));
----

[[cassandra.cql-template.examples.other]]
==== Other `CqlTemplate` operations

You can use the `execute(..)` method to execute any arbitrary CQL.  As such, the method is often used for DDL statements.
It is heavily overloaded with variants taking callback interfaces, binding variable arrays, and so on.

This example shows how to create and drop a table, using different API objects, all passed to the `execute()` methods.

[source,java]
----
cqlOperations.execute("CREATE TABLE test_table (id uuid primary key, event text)");

DropTableSpecification dropper = DropTableSpecification.dropTable("test_table");
String cql = DropTableCqlGenerator.toCql(dropper);

cqlTemplate.execute(cql);
----

[[cassandra.exception]]
include::exception-translation.adoc[]

[[cassandra.connections]]
== Controlling Cassandra connections

Applications connect to Apache Cassandra using `Cluster` and `Session` objects. A Cassandra `Session` keeps track of
multiple connections to the individual nodes and is designed to be a Thread-safe, long-lived object.
Usually, it's sufficient to use a single `Session` for the whole application.

Spring acquires a Cassandra `Session` through a `SessionFactory`. `SessionFactory` is part of
Spring Data for Apache Cassandra and is a generalized connection factory.
It allows the container or framework to hide connection handling and routing issues from the application code.

Here is an example of how to configure a default `SessionFactory` in Java code:

[source,java]
----
Session session = … // get hold of a Cassandra Session

CqlTemplate template = new CqlTemplate();

template.setSessionFactory(new DefaultSessionFactory(session));
----

`CqlTemplate` and other Template API implementations obtain a `Session` for each operation. Due to their
long-lived nature, Sessions are not closed after invoking the desired operation. Responsibility for proper
resource disposal lies with the container or framework using the Session.

You can find various `SessionFactory` implementations within the `org.springframework.data.cassandra.core.cql.session`
package.

[[cassandra.template]]
== Introduction to `CassandraTemplate`

The `CassandraTemplate` class, located in the package `org.springframework.data.cassandra`, is the central class
in Spring's Cassandra support providing a rich feature set to interact with the database. The template offers
convenience operations to create, update, delete and query Cassandra, and provides a mapping between your domain objects
and rows in Cassandra tables.

NOTE: Once configured, `CassandraTemplate` is Thread-safe and can be reused across multiple instances.

The mapping between rows in Cassandra and application domain classes is done by delegating to an implementation
of the `CassandraConverter` interface. Spring provides a default implementation, `MappingCassandraConverter`,
but you can also write your own custom converter. Please refer to the section on
<<mapping-chapter,Cassandra conversion>> for more detailed information.

The `CassandraTemplate` class implements the `CassandraOperations` interface. In as much as possible, the methods
on `CassandraOperations` are named after methods available in Cassandra to make the API familiar to existing
Cassandra developers who are already familiar with Cassandra.

For example, you will find methods such as "select", "insert", "delete", and "update". The design goal was to make it
as easy as possible to transition between the use of the base Cassandra driver and `CassandraOperations`.
A major difference in between the two APIs is that `CassandraOperations` can be passed domain objects instead of CQL
and query objects.

NOTE: The preferred way to reference operations on a `CassandraTemplate` instance is via its interface,
`CassandraOperations`.

The default converter implementation used by `CassandraTemplate` is `MappingCassandraConverter`.
While the `MappingCassandraConverter` can make use of additional metadata to specify the mapping of objects
to rows it is also capable of converting objects that contain no additional metadata by using some conventions
for the mapping of fields and table names. These conventions as well as the use of mapping annotations is explained
in the <<mapping.chapter,Mapping chapter>>.

Another central feature of `CassandraTemplate` is exception translation of exceptions thrown in the Cassandra
Java driver into Spring's portable Data Access Exception hierarchy. Refer to the section on
<<cassandra.exception,exception translation>> for more information.

NOTE: `CassandraTemplate` comes in different execution model flavors. The basic `CassandraTemplate` uses a
blocking execution model. You can use `AsyncCassandraTemplate` for asynchronous execution and synchronization
with ``ListenableFuture``s or <<cassandra.reactive.template,`ReactiveCassandraTemplate`>> for reactive execution.

Now let's look at examples of how to work with the `CassandraTemplate` in the context of the Spring container.

[[cassandra.template.instantiating]]
=== Instantiating CassandraTemplate

`CassandraTemplate` should always be configured as a Spring bean, although we show an example above where
you can instantiate it directly. But, for the purposes of this being a Spring module, lets assume we are using
the Spring container.

There are 2 easy ways to get a `CassandraTemplate`, depending on how you load you Spring `ApplicationContext`.

[float]
==== Autowiring

[source,java]
----
@Autowired
private CassandraOperations cassandraOperations;
----

Like all Spring Autowiring, this assumes there is only one bean of type `CassandraOperations` in the `ApplicationContext`.
If you have multiple `CassandraTemplate` beans (which will be the case if you are working with multiple Keyspaces
in the same project), then use the `@Qualifier`annotation to designate which bean you want to Autowire.

[source,java]
----
@Autowired
@Qualifier("keyspaceOneTemplateBeanId")
private CassandraOperations cassandraOperations;
----

[float]
==== Bean Lookup with ApplicationContext

You can also just lookup the `CassandraTemplate` bean from the `ApplicationContext`.

[source,java]
----
CassandraOperations cassandraOperations = applicationContext.getBean("cassandraTemplate", CassandraOperations.class);
----

[[cassandra-template.save-update-remove]]
== Saving, Updating, and Removing Rows

`CassandraTemplate` provides a simple way for you to save, update, and delete your domain objects, and map those objects
to tables managed in Cassandra.

[[cassandra.template.type-mapping]]
=== Type mapping

Spring Data for Apache Cassandra relies on the DataStax Java Driver's `CodecRegistry` to ensure type support. As types
are added or changed, the Spring Data for Apache Cassandra module will continue to function without requiring changes.
See https://docs.datastax.com/en/cql/3.3/cql/cql_reference/cql_data_types_c.html[CQL data types]
and <<mapping-conversion>> for the current type mapping matrix.

[[cassandra.template.insert-update]]
=== Methods for inserting and updating rows

There are several convenient methods on `CassandraTemplate` for saving and inserting your objects. To have more
fine-grained control over the conversion process you can register Spring `Converters` with the `MappingCassandraConverter`.
For example, `Converter<Row, Person>`.

NOTE: The difference between insert and update operations is that an `INSERT` operation will not insert `null` values.

The simple case of using the insert operation is to save a POJO. In this case, the table name will be determined
by the simple name of the class (not fully-qualified). The table to store the object can be overridden
using mapping metadata.

When inserting or updating, the `id` property must be set. There is no means to generate an ID with Apache Cassandra.

Here is a basic example of using the save operation and retrieving its contents.

.Inserting and retrieving objects using the `CassandraTemplate`
====
[source,java]
----
import static org.springframework.data.cassandra.core.query.Criteria.where;
import static org.springframework.data.cassandra.core.query.Query.query;
…

Person bob = new Person("Bob", 33);
cassandraTemplate.insert(bob);

Person queriedBob = cassandraTemplate.selectOneById(query(where("age").is(33)), Person.class);
----
====

The insert/save operations available to you are listed below.

* `void` *insert* `(Object objectToSave)` Insert the object in an Apache Cassandra table.
* `WriteResult` *insert* `(Object objectToSave, InsertOptions options)` Insert the object in an Apache Cassandra table
applying `InsertOptions`.

A similar set of update operations is listed below

* `void` *update* `(Object objectToSave)` Update the object in an Apache Cassandra table.
* `WriteResult` *update* `(Object objectToSave, UpdateOptions options)` Update the object in an Apache Cassandra table
applying `UpdateOptions`.

Then, there is always the old fashioned way; you can write your own CQL statements.

[source,java]
----
String cql = "INSERT INTO person (age, name) VALUES (39, 'Bob')";

cassandraTemplate().getCqlOperations().execute(cql);
----

You can also configure additional options such as TTL, consistency level and lightweight transactions
using `InsertOptions` and `UpdateOptions`.

[[cassandra.template.insert-update.table]]
==== Which table will my rows be inserted into?

There are two ways to manage the collection name that is used for operating on the tables. The default table name
that is used is the simple class name changed to start with a lower-case letter. So, an instance of
the `com.example.Person` class would be stored in the "person" table.

You can customize this by providing a different collection name using the `@Table` annotation.

[[cassandra.template.batch]]
==== Inserting, updating and deleting individual objects in a batch

The Cassandra protocol supports inserting a collection of rows in one operation using a batch.

The methods in the `CassandraTemplate` interface supporting this functionality are listed below.

* *batchOps* Creates a new `CassandraBatchOperations` to populate the batch

`CassandraBatchOperations`

* *insert* Takes a single object, an array (var-args) or an `Iterable` of objects to insert.
* *update* Takes a single object, an array (var-args) or an `Iterable` of objects to update.
* *delete* Takes a single object, an array (var-args) or an `Iterable` of objects to delete.
* *withTimestamp* Applies a TTL to the batch.
* *execute* Executes the batch.

[[cassandra.template.update]]
=== Updating rows in a table

For updates, we can select to update a number of rows.

Here is an example of updating a single account object where we are adding a one-time $50.00 bonus to the balance
using the `+` assignment.

.Updating rows using `CasandraTemplate`
====
[source,java]
----
import static org.springframework.data.cassandra.core.query.Criteria.where;
import org.springframework.data.cassandra.core.query.Query;
import org.springframework.data.cassandra.core.query.Update;

...

boolean applied = cassandraTemplate.update(Query.query(where("id").is("foo")),
  Update.create().increment("balance", 50.00), Account.class);
----
====

In addition to the `Query` discussed above, we provide the update definition using an `Update` object.
The `Update` class has methods that match the update assignments available for Apache Cassandra.

As you can see most methods return the `Update` object to provide a fluent API for code styling purposes.

[[cassandra.template.update.methods]]
==== Methods for executing updates for rows

* `boolean` *update* `(Query query, Update update, Class<?> entityClass)` Update a selection of objects in
the Apache Cassandra table.

[[cassandra.template.update.update]]
==== Methods for the Update class

The `Update` class can be used with a little 'syntax sugar' as its methods are meant to be chained together
and you can kick-start the creation of a new `Update` instance via the static method
`public static Update update(String key, Object value)` and using static imports.

Here is a listing of methods on the `Update` class.

* `AddToBuilder` *addTo* `(String columnName)` `AddToBuilder` entry-point:
    ** Update `prepend(Object value)` Prepend a collection value to the existing collection using the `+` update assignment.
    ** Update `prependAll(Object... values)` Prepend all collection value to the existing collection using the `+` update assignment.
    ** Update `append(Object value)` Append a collection value to the existing collection using the `+` update assignment.
    ** Update `append(Object... values)` Append all collection value to the existing collection using the `+` update assignment.
    ** Update `entry(Object key, Object value)` Add a map entry using the `+` update assignment.
    ** Update `addAll(Map<? extends Object, ? extends Object> map)` Add all map entries to the map using the `+` update assignment.
* `Update` *remove* `(String columnName, Object value)` Remove the value from the collection using the `-` update assignment.
* `Update` *clear* `(String columnName)` Clear the collection
* `Update` *increment* `(String columnName, Number delta)` Update using the `+` update assignment
* `Update` *decrement* `(String columnName, Number delta)` Update using the `-` update assignment
* `Update` *set* `(String columnName, Object value)` Update using the `=` update assignment
* `SetBuilder` *set* `(String columnName)` `SetBuilder` entry-point:
    ** Update `atIndex(int index).to(Object value)` Set a collection at the given index to a value using the `=` update assignment.
    ** Update `atKey(String object).to(Object value)` Set a map entry at the given key to a value the `=` update assignment.

[source]
----
// UPDATE … SET key = 'Spring Data';
Update.update("key", "Spring Data")

// UPDATE … SET key[5] = 'Spring Data';
Update.empty().set("key").atIndex(5).to("Spring Data");

// UPDATE … SET key = key + ['Spring', 'DATA'];
Update.empty().addTo("key").appendAll("Spring", "Data");
----

`Update` is immutable once created. Invoking methods will create new immutable (intermediate) `Update` objects.

[[cassandra.template.delete]]
=== Methods for removing rows

You can use several overloaded methods to remove an object from the database.

* `boolean` *delete* `(Query query, Class<?> entityClass)` Delete the objects selected by `Query`.
* `T` *delete* `(T entity)` Delete the given object.
* `T` *delete* `(T entity, QueryOptions queryOptions)` Delete the given object applying `QueryOptions`.
* `boolean` *deleteById* `(Object id, Class<?> entityClass)` Delete the object using the given Id.

[[cassandra.template.query]]
== Querying Rows

You can express your queries using the `Query` and `Criteria` classes, which have method names that reflect
the native Cassandra predicate operator names such as `lt`, `lte`, `is`, and others.

The `Query` and `Criteria` classes follow a fluent API style so you can easily chain together multiple method criteria
and queries while having easy to understand the code. Static imports are used in Java when creating `Query`
and `Criteria` instances to improve readability.


[[cassandra.template.query.table]]
=== Querying rows in a table

We saw how to retrieve a single object using the `selectOneById` method on `CassandraTemplate` in previous sections,
which return a single domain object. We can also query for a collection of rows to be returned as a
list of domain objects. Assuming we have a number of Person objects with name and age stored as rows in a table
and that each person has an account balance, we can now run a query using the following code.

.Querying for rows using `CassandraTemplate`
====
[source,java]
----
import static org.springframework.data.cassandra.core.query.Criteria.where;
import static org.springframework.data.cassandra.core.query.Query.query;

…

List<Person> result = cassandraTemplate.select(query(where("age").is(50))
  .and(where("balance").gt(1000.00d)).withAllowFiltering(), Person.class);
----
====

`select`, `selectOneById` and `stream` methods take a `Query` object as a parameter. This object defines the criteria
and options used to perform the query. The criteria is specified using a `Criteria` object that has
a static factory method named `where` used to instantiate a new `Criteria` object. We recommend using a static import
for `org.springframework.data.cassandra.core.query.Criteria.where` and `Query.query` to make the query more readable.

This query should return a list of `Person` objects that meet the specified criteria. The `Criteria` class has
the following methods that correspond to the operators provided in Apache Cassandra.

[[cassandra.template.query.criteria]]
==== Methods for the Criteria class

* `CriteriaDefinition` *gt* `(Object value)` Creates a criterion using the `>` operator.
* `CriteriaDefinition` *gte* `(Object value)` Creates a criterion using the `>=` operator.
* `CriteriaDefinition` *in* `(Object... values)` Creates a criterion using the `IN` operator for a varargs argument.
* `CriteriaDefinition` *in* `(Collection<?> collection)` Creates a criterion using the `IN` operator using a collection.
* `CriteriaDefinition` *is* `(Object value)` Creates a criterion using field matching (`column = value`).
* `CriteriaDefinition` *lt* `(Object value)` Creates a criterion using the `<` operator.
* `CriteriaDefinition` *lte* `(Object value)` Creates a criterion using the `<=` operator.
* `CriteriaDefinition` *like* `(Object value)` Creates a criterion using the `LIKE` operator.
* `CriteriaDefinition` *contains* `(Object value)` Creates a criterion using the `CONTAINS` operator.
* `CriteriaDefinition` *containsKey* `(Object key)` Creates a criterion using the `CONTAINS KEY` operator.

`Criteria` is immutable once created.

The `Query` class has some additional methods used to provide options for the query.

[[cassandra.template.query.query-class]]
==== Methods for the Query class

* `Query` *by* `(CriteriaDefinition... criteria)` used to create a `Query` object.
* `Query` *and* `(CriteriaDefinition criteria)` used to add additional criteria to the query.
* `Query` *columns* `(Columns columns)` used to define columns to be included in the query results.
* `Query` *limit* `(long limit)` used to limit the size of the returned results to the provided limit (used for paging).
* `Query` *pageRequest* `(Pageable pageRequest)` used to associate `Sort`, `PagingState` and `fetchSize` with the query (used for paging).
* `Query` *pagingState* `(PagingState pagingState)` used to associate a `PagingState` with the query (used for paging).
* `Query` *queryOptions* `(QueryOptions queryOptions)` used to associate `QueryOptions` with the query.
* `Query` *sort* `(Sort sort)` used to provide sort definition for the results.
* `Query` *withAllowFiltering* `()` used render `ALLOW FILTERING` queries.

`Query` is immutable once created. Invoking methods will create new immutable (intermediate) `Query` objects.

[[cassandra.template.query.rows]]
=== Methods for querying for rows

The query methods need to specify the target type T that will be returned.

* `List<T>` *select* `(Query query, Class<T> entityClass)` Query for a list of objects of type T from the table.
* `T` *selectOneById* `(Query query, Class<T> entityClass)` Query for a single object of type T from the table.
* `Slice<T>` *slice* `(Query query, Class<T> entityClass)` Start or continue paging by querying for a `Slice` of objects of type T from the table.
* `T` *selectOne* `(Query query, Class<T> entityClass)` Query for a single object of type T from the table.
* `Stream<T>` *stream* `(Query query, Class<T> entityClass)` Query for a stream of objects of type T from the table.
* `List<T>` *select* `(String cql, Class<T> entityClass)` Ad-hoc query for a list of objects of type T from the table providing a CQL statement.
* `T` *selectOneById* `(String cql, Class<T> entityClass)` Ad-hoc query for a single object of type T from the table providing a CQL statement.
* `Stream<T>` *stream* `(String cql, Class<T> entityClass)` Ad-hoc query for a stream of objects of type T from the table providing a CQL statement.

[[cassandra.template.query.fluent-template-api]]
=== Fluent Template API

The `CassandraOperations` interface is one of the central components when it comes to more low-level interaction
with Apache Cassandra. It offers a wide range of methods. One can find multiple overloads for each and every method.
Most of them just cover optional (nullable) parts of the API.

`FluentCassandraOperations` provide a more narrow interface for common methods of `CassandraOperations`
providing a more readable, fluent API. The entry points `query(…)`, `insert(…)`, `update(…)`, and `delete(…)`
follow a natural naming scheme based on the operation to execute. Moving on from the entry point, the API
is designed to only offer context dependent methods guiding the developer towards a terminating method
that invokes the actual `CassandraOperation`.

====
[source,java]
----
List<SWCharacter> all = ops.query(SWCharacter.class)
  .inTable("star_wars")                        <1>
  .all();
----
<1> Skip this step if `SWCharacter` defines the table name via `@Table` or if using the class name as table name is just fine.
====

If a table in Cassandra holds entities of different types, like a `Jedi` within a Table of `SWCharacters`, you can use
different types to map the query result. Use `as(Class<?> targetType)` to map results to a different target type
while `query(Class<?> entityType)` still applies to the query and table name.

====
[source,java]
----
List<Jedi> all = ops.query(SWCharacter.class)    <1>
  .as(Jedi.class)                                <2>
  .matching(query(where("jedi").is(true)))
  .all();
----
<1> The query fields are mapped against the `SWCharacter` type.
<2> Resulting rows are mapped into `Jedi`.
====

TIP: It is possible to directly apply <<projections>> to resulting documents by providing just the `interface` type
via `as(Class<?>)`.

Switching between retrieving a single entity, multiple entities as `List` or `Stream`, and the like is done
via the terminating methods `first()`, `one()`, `all()` or `stream()`.

WARNING: The new fluent template API methods (i.e. `query(..)`, `insert(..)`, `update(..)` and `delete(..)`)
makes use of effectively Thread-safe supporting objects to compose the CQL statement.  However, it comes
at the added cost of additional young-gen JVM heap overhead since the design is based on final fields
for the various CQL statement components and construction on mutation.  You should be careful when possibly
inserting or deleting a large number of object, such as inside a loop, for instance.
